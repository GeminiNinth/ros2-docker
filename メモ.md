dockerにおいてROS2入りのコンテナを立ち上げたい
以下のconfig.shを設定する。

```bash
# コンテナ名。terminatorのウィンドウ名にも反映される。
CONTAINER_NAME=ros2_humble_test

# イメージの基本設定
# ベースイメージの設定。タグは https://hub.docker.com/r/nvidia/opengl/tags?name=base-ubuntu から調べる
BASE_IMAGE="base-ubuntu22.04"
ROS_DISTRO=humble
IMAGE_NAME=ros2_${ROS_DISTRO}

# ホスト側PCの設定
DEV_WS=${HOME}/dev_ws # terminatorの設定ファイル置き場
HOST_WORKSPACE=${HOME}/ros_ws/${IMAGE_NAME}

# コンテナ側設定
CONTAINER_WORKSPACE=/root/colcon_ws
```

build_Dockerfile.shは
```bash
#!/bin/bash

# config.shの読み込み
source config.sh

# 必要なディレクトリの作成
echo "Creating necessary directories for ROS ${ROS_DISTRO}..."
mkdir -p ${HOST_WORKSPACE}/build
mkdir -p ${HOST_WORKSPACE}/install
mkdir -p ${HOST_WORKSPACE}/log
mkdir -p ${HOST_WORKSPACE}/src
mkdir -p ${DEV_WS}/config/terminator
echo ""

# Dockerfileの実行
echo "Building Image..."
echo BASE_IMAGE=${BASE_IMAGE}
echo ROS_DISTRO=${ROS_DISTRO}
echo CONTAINER_WORKSPACE=${CONTAINER_WORKSPACE}
echo IMAGE_NAME=${IMAGE_NAME}

docker build -t ${IMAGE_NAME} --build-arg BASE_IMAGE=${BASE_IMAGE} --build-arg ROS_DISTRO=${ROS_DISTRO} --build-arg CONTAINER_NAME=${CONTAINER_NAME} --build-arg CONTAINER_WORKSPACE=${CONTAINER_WORKSPACE} .

echo "Image built successfully!"
```

```Dockerfile
ARG BASE_IMAGE
FROM nvidia/opengl:${BASE_IMAGE}

ARG ROS_DISTRO
ARG CONTAINER_NAME
ARG CONTAINER_WORKSPACE

ENV BASE_IMAGE=${BASE_IMAGE}
ENV ROS_DISTRO=${ROS_DISTRO}
ENV CONTAINER_WORKSPACE=${CONTAINER_WORKSPACE}
ENV CONTAINER_NAME=${CONTAINER_NAME}

# 環境変数の設定
ENV DEBIAN_FRONTEND=noninteractive
ENV __NV_PRIME_RENDER_OFFLOAD=1
ENV __GLX_VENDOR_LIBRARY_NAME=nvidia

# 必要なパッケージのインストール
RUN apt-get update && apt-get install -y \
    curl \
    gnupg \
    lsb-release \
    sudo \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

# ROSのリポジトリをsource listに追加
RUN curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | apt-key add - \
    && echo "deb http://packages.ros.org/ros2/ubuntu $(lsb_release -cs) main" > /etc/apt/sources.list.d/ros2-latest.list


# ROS2のインストール
RUN apt-get update && apt-get install -y --no-install-recommends \
    ros-${ROS_DISTRO}-desktop \
    ros-dev-tools \
    && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# colconとrosdep、GUIや解析に用いるパッケージのインストール
RUN apt-get update && apt-get install -y --no-install-recommends \
    python3-colcon-common-extensions \
    python3-rosdep \
    gazebo \
    ros-${ROS_DISTRO}-gazebo-* \
    ros-${ROS_DISTRO}-rqt-* \
    ros-${ROS_DISTRO}-plotjuggler-ros \
    terminator \
    && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# ワークスペースの作成
RUN apt-get update && apt-get upgrade -y && \
    rosdep init && \
    rosdep update

# エントリーポイントと必要なスクリプトをイメージ内(rootディレクトリ配下)に設定
COPY shell_scripts/ros_entrypoint.sh /
COPY shell_scripts/start_terminator.sh /
RUN chmod +x /ros_entrypoint.sh /start_terminator.sh

# ビープ音の無効化（うざいので）
RUN echo "set bell-style none" >> ~/.inputrc

# 再起動時もENTRYPOINTを再実行させる
ENTRYPOINT ["/bin/bash", "-c", "/ros_entrypoint.sh ${ROS_DISTRO} ${CONTAINER_WORKSPACE} ${CONTAINER_NAME} "]
```

ros_entrypoint.sh
```bash
#!/bin/bash

ROS_DISTRO=$1
CONTAINER_WORKSPACE=$2
CONTAINER_NAME=$3 # start_terminator.sh内で利用

# ROSの環境を設定
if [ -f "/opt/ros/${ROS_DISTRO}/setup.bash" ]; then
    source /opt/ros/${ROS_DISTRO}/setup.bash
else
    echo "Error: /opt/ros/${ROS_DISTRO}/setup.bash not found!"
    exit 1
fi

# ワークスペースの各ディレクトリの確認と作成
for DIR in build install log src; do
    if [ ! -d "${CONTAINER_WORKSPACE}/${DIR}" ]; then
        mkdir -p ${CONTAINER_WORKSPACE}/${DIR}
    fi
done

if [ ! -d "/root/.config/terminator" ]; then
    mkdir -p /root/.config/terminator
fi

# ROS環境のセットアップ（.bashrcに重複追加しないようにチェック）
if ! grep -Fxq "source /opt/ros/${ROS_DISTRO}/setup.bash" /root/.bashrc; then
    echo "source /opt/ros/${ROS_DISTRO}/setup.bash" >> /root/.bashrc
fi

# ターミナルが存在しない場合（再attach時）に Terminator を再起動
if ! pgrep -x "terminator" > /dev/null; then
    bash /start_terminator.sh ${CONTAINER_NAME}
fi

# 終了せずに常駐プロセスを保持
tail -f /dev/null
```

start_terminator.shは
```bash
#!/bin/bash

# Terminatorの起動
terminator --title=${CONTAINER_NAME} & 

# フォアグラウンドのプロセスを維持
tail -f /dev/null
```

さて、ros_entrypoint.shにCONTAINER_NAMEを渡すことでterminatorのウィンドウ名を変更できるようになっている。

以下のスクリプトファイルを実行することでコンテナを作成する。

create_container.sh
```bash
#!/bin/bash

# config.shの読み込み
source config.sh

# rockerコマンドの実行（ディストリビューションごとのコンテナを立ち上げ）
# コンテナ間の共有メモリのデバイスファイルをマウントすることでコンテナ間の通信が可能
echo "Starting rocker with ${CONTAINER_NAME} and Terminator config..."
rocker --nvidia --x11 --network host --privileged --nocleanup --name ${CONTAINER_NAME} \
  ${IMAGE_NAME}:latest \
  --volume ${HOST_WORKSPACE}/build:${CONTAINER_WORKSPACE}/build \
  --volume ${HOST_WORKSPACE}/install:${CONTAINER_WORKSPACE}/install \
  --volume ${HOST_WORKSPACE}/log:${CONTAINER_WORKSPACE}/log \
  --volume ${HOST_WORKSPACE}/src:${CONTAINER_WORKSPACE}/src \
  --volume ${DEV_WS}/config/terminator:/root/.config/terminator \
  --volume=/dev/shm:/dev/shm:rw \
  --volume=/dev:/dev \
  --env BASE_IMAGE=${BASE_IMAGE} \
  --env ROS_DISTRO=${ROS_DISTRO} \
  --env IMAGE_NAME=${IMAGE_NAME} \
  --env CONTAINER_WORKSPACE=${CONTAINER_WORKSPACE} 
```

しかしこのようなやり方では、build_Dockerfile.sh内でコンテナ名を設定してしまっているため、新たなイメージ名でコンテナを作成したいときにも再びbuild_Dockerfile.shを実行しないといけない。

イメージ作成部分とコンテナ作成部分を分離し、新たな名前のコンテナを作成するときにもいちいちイメージビルドを行わなくても良いようにしてください